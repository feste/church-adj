(define (last lst)
  (first (fold (lambda (a lst) (append (list a) lst)) '() lst)))

;100 bins
(define bins
  (mem
   (lambda (item)
     (case item
           (('watch) '((30  90 150 210 270 330 390 450 510 570)
                       (0.651250 0.765625 0.725000 0.639375 0.520000 0.400000 0.333750 0.242500 0.201875 0.171250)))
           (('coffee-maker) '((20  60 100 140 180 220 260 300 340 380)
                              (0.71058824 0.74000000 0.71000000 0.53470588 0.41647059 0.18294118 0.12058824 0.06941176 0.04294118 0.01705882)))
           (('sweater) '((20  60 100 140 180 220 260 300 340 380)
                         (0.84941176 0.73764706 0.56470588 0.35294118 0.20529412 0.15058824 0.09000000 0.07588235 0.04352941 0.03117647)))
           (('laptop) '((280  840 1400 1960 2520 3080 3640 4200 4760 5320)
                        (0.48769231 0.83846154 0.65384615 0.36923077 0.18923077 0.12846154 0.09538462 0.05076923 0.04000000 0.01384615)))
           (('headphones) '((15  45  75 105 135 165 195 225 255 285)
                            (0.7035294 0.7305882 0.7276471 0.6711765 0.6000000 0.3658824 0.2852941 0.2482353 0.2058824 0.1335294)))))))

(define (prior item) (apply multinomial (bins item)))
(define (theta-prior item) (uniform-draw (first (bins item))))

(define (utterance-prior) (multinomial '(expensive no-utt) '(0.3678794 1)))

(define pragmatic-listener
  (mem (lambda (utterance item)
         ;query price and theta given speaker would have said that
         (mh-query 30000 5
                   (define price (apply multinomial (bins item)))
                   (define theta (theta-prior item))
                   (list price theta)
                   (eq? (apply multinomial (speaker price theta item)) utterance)))))

(define speaker
  (mem (lambda (price theta item)
         ;query utterance given literal listener would guess price given theta
         (enumeration-query
          (define u (utterance-prior))
          u
          (eq? (apply multinomial (literal-listener u theta item)) price)))))

(define literal-listener
  (mem (lambda (u theta item)
         (define bin (bins item))
         (define (post-utterance)
           (define bin-pairs (map list
                                  (first bin)
                                  (second bin)))
           (define filtered-bin-pairs (fold
                                       (lambda (a lst) (if (>= (first a) theta)
                                                           (pair a lst)
                                                           lst))
                                       '()
                                       bin-pairs))
           (list (map first filtered-bin-pairs) (map second filtered-bin-pairs)))
         (if (eq? u 'expensive)
             (post-utterance)
             bin))))


(define sorites-model
  (mem
   (lambda (item)
     ;human data for comparison
     (define people (case item
                          (('watch) '(8.308824 8.454545 7.652778 6.826667 6.255319 5.750000))
                          (('laptop) '(8.394366 8.337838 7.179104 5.214286 4.550000 3.536585))
                          (('coffee-maker) '(8.554054 7.746269 6.613333 6.171875 5.150000 4.414634))
                          (('headphones) '(8.460526 7.985075 5.936508 5.337500 4.352941 4.045455))
                          (('sweater) '(8.655738 7.973684 7.027397 6.377049 5.179487 4.000000))))
     
     
     ;human standard deviations from experiment
     (define epsilons (map (lambda (e) (* e (case item
                                                  (('watch) 15.28736)
                                                  (('laptop) 254.2707)
                                                  (('coffee-maker) 22.31799)
                                                  (('headphones) 31.54902)
                                                  (('sweater) 15.28736))))
                           '(0.01 0.10 0.50 1.00 2.00 3.00)))
     
     ;results of model-
     (define samples (pragmatic-listener 'expensive item))
     (define prices (map first samples))
     (define thetas (map second samples))
     
     ;inductive premise
     (define (inductive e)
       (define lst (map (lambda (p t) (if (>= (- p e) t) 1 0)) prices thetas))
       ;get mean value of inductive premise
       (/ (apply + lst) (length lst)))
     
     (define model-judgements (map inductive epsilons))
     ;comparison: people to model
     (define people-vs-model (map pair
                                  people
                                  (map inductive epsilons)))
     (list people-vs-model
           model-judgements
           prices
           thetas))))

(define items '(watch
                laptop
                coffee-maker
                headphones
                sweater))

(define ppl-vs-mod (fold
                    append
                    '()
                    (map (lambda (item) (first (sorites-model item))) items)))

(list
 'watch
 (second (sorites-model 'watch))
 (mean (third (sorites-model 'watch)))
 (mean (fourth (sorites-model 'watch)))
 'laptop
 (second (sorites-model 'laptop))
 (mean (third (sorites-model 'laptop)))
 (mean (fourth (sorites-model 'laptop)))
 'coffee-maker
 (second (sorites-model 'coffee-maker))
 (mean (third (sorites-model 'coffee-maker)))
 (mean (fourth (sorites-model 'coffee-maker)))
 'headphones
 (second (sorites-model 'headphones))
 (mean (third (sorites-model 'headphones)))
 (mean (fourth (sorites-model 'headphones)))
 'sweater
 (second (sorites-model 'sweater))
 (mean (third (sorites-model 'sweater)))
 (mean (fourth (sorites-model 'sweater))))